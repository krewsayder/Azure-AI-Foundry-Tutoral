"""
cluster.py - Cluster and visualize risk assessment embeddings.

Reads output/embeddings.json (generated by embed.py), performs:
  1. K-Means clustering to find natural risk theme groupings
  2. UMAP dimensionality reduction (1536D -> 2D) for visualization
  3. Interactive Plotly scatter plot saved as HTML

Usage:
    python src/cluster.py
    python src/cluster.py --clusters 6    # override number of clusters
"""

import argparse
import json
import sys
from pathlib import Path

import numpy as np
import pandas as pd
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import normalize
from umap import UMAP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

PROJECT_ROOT = Path(__file__).resolve().parent.parent
EMBEDDINGS_PATH = PROJECT_ROOT / "output" / "embeddings.json"
OUTPUT_DIR = PROJECT_ROOT / "output"

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def load_embeddings(path: Path) -> tuple[pd.DataFrame, np.ndarray]:
    """Load embeddings JSON and return metadata DataFrame + embedding matrix."""
    if not path.exists():
        print(f"ERROR: Embeddings file not found at {path}")
        print("Run 'python src/embed.py' first to generate embeddings.")
        sys.exit(1)

    with open(path) as f:
        data = json.load(f)

    print(f"Loaded {data['count']} embeddings (dimension: {data['dimension']})")

    records = data["records"]
    df = pd.DataFrame([{
        "risk_id": r["risk_id"],
        "function": r["function"],
        "risk_owner": r["risk_owner"],
        "risk_description": r["risk_description"],
    } for r in records])

    embeddings = np.array([r["embedding"] for r in records])
    return df, embeddings


def find_optimal_clusters(embeddings: np.ndarray, k_range: range = range(3, 10)) -> int:
    """Use silhouette score to find the best k for K-Means."""
    print("\nFinding optimal cluster count...")
    best_k = k_range.start
    best_score = -1

    for k in k_range:
        km = KMeans(n_clusters=k, random_state=42, n_init=10)
        labels = km.fit_predict(embeddings)
        score = silhouette_score(embeddings, labels)
        print(f"  k={k}: silhouette score = {score:.4f}")
        if score > best_score:
            best_score = score
            best_k = k

    print(f"  -> Best k = {best_k} (score: {best_score:.4f})")
    return best_k


def cluster_embeddings(embeddings: np.ndarray, n_clusters: int) -> np.ndarray:
    """Run K-Means clustering on the embedding matrix."""
    print(f"\nClustering into {n_clusters} groups...")
    km = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    labels = km.fit_predict(embeddings)
    return labels


def reduce_dimensions(embeddings: np.ndarray) -> np.ndarray:
    """Reduce embedding dimensions to 2D using UMAP."""
    print("Reducing dimensions with UMAP (1536D -> 2D)...")
    reducer = UMAP(
        n_components=2,
        n_neighbors=15,
        min_dist=0.1,
        metric="cosine",
        random_state=42,
    )
    coords = reducer.fit_transform(embeddings)
    return coords


def label_clusters(df: pd.DataFrame) -> dict[int, str]:
    """
    Generate human-readable cluster labels based on the most common
    function and keywords in each cluster's risk descriptions.
    """
    cluster_labels = {}
    for cluster_id in sorted(df["cluster"].unique()):
        cluster_df = df[df["cluster"] == cluster_id]
        top_function = cluster_df["function"].mode().iloc[0]
        count = len(cluster_df)
        cluster_labels[cluster_id] = f"Cluster {cluster_id} — {top_function} ({count} risks)"
    return cluster_labels


# ---------------------------------------------------------------------------
# Visualization
# ---------------------------------------------------------------------------

def create_visualization(df: pd.DataFrame, output_dir: Path):
    """Create an interactive Plotly scatter plot of clustered embeddings."""
    print("\nBuilding interactive visualization...")

    # Truncate descriptions for hover text
    df["short_desc"] = df["risk_description"].str[:120] + "..."

    fig = px.scatter(
        df,
        x="umap_x",
        y="umap_y",
        color="cluster_label",
        hover_data={
            "risk_id": True,
            "function": True,
            "risk_owner": True,
            "short_desc": True,
            "umap_x": False,
            "umap_y": False,
            "cluster_label": False,
        },
        title="Risk Assessment Embeddings — Clustered by Semantic Similarity",
        labels={
            "cluster_label": "Cluster",
            "umap_x": "",
            "umap_y": "",
        },
        width=1100,
        height=700,
    )

    fig.update_traces(marker=dict(size=10, line=dict(width=1, color="white")))
    fig.update_layout(
        plot_bgcolor="#fafafa",
        font=dict(family="Segoe UI, sans-serif", size=12),
        title_font_size=18,
        legend=dict(
            title="Risk Clusters",
            font=dict(size=11),
            bordercolor="#ccc",
            borderwidth=1,
        ),
        xaxis=dict(showgrid=False, showticklabels=False, title=""),
        yaxis=dict(showgrid=False, showticklabels=False, title=""),
    )

    # Save interactive HTML
    html_path = output_dir / "risk_clusters.html"
    fig.write_html(str(html_path), include_plotlyjs=True)
    print(f"Interactive chart saved to {html_path}")

    # Save static PNG
    png_path = output_dir / "risk_clusters.png"
    try:
        fig.write_image(str(png_path), scale=2)
        print(f"Static image saved to {png_path}")
    except Exception as e:
        print(f"Note: Could not save PNG ({e}). HTML version is available.")

    # Save cluster summary
    summary_path = output_dir / "cluster_summary.csv"
    summary = df.groupby("cluster_label").agg(
        count=("risk_id", "count"),
        functions=("function", lambda x: ", ".join(sorted(x.unique()))),
        risk_ids=("risk_id", lambda x: ", ".join(sorted(x))),
    ).reset_index()
    summary.to_csv(summary_path, index=False)
    print(f"Cluster summary saved to {summary_path}")

    return html_path


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Cluster and visualize risk embeddings")
    parser.add_argument("--clusters", type=int, default=0,
                        help="Number of clusters (0 = auto-detect)")
    args = parser.parse_args()

    print("=" * 60)
    print("Risk Embedding Cluster Analysis")
    print("=" * 60)

    # Load
    df, embeddings = load_embeddings(EMBEDDINGS_PATH)

    # Normalize embeddings for cosine-based clustering
    embeddings_norm = normalize(embeddings)

    # Cluster
    if args.clusters > 0:
        n_clusters = args.clusters
    else:
        n_clusters = find_optimal_clusters(embeddings_norm)

    labels = cluster_embeddings(embeddings_norm, n_clusters)
    df["cluster"] = labels

    # Label clusters
    cluster_labels = label_clusters(df)
    df["cluster_label"] = df["cluster"].map(cluster_labels)

    # Reduce dimensions
    coords = reduce_dimensions(embeddings_norm)
    df["umap_x"] = coords[:, 0]
    df["umap_y"] = coords[:, 1]

    # Print cluster breakdown
    print("\n" + "-" * 60)
    print("CLUSTER BREAKDOWN")
    print("-" * 60)
    for label in sorted(df["cluster_label"].unique()):
        cluster_df = df[df["cluster_label"] == label]
        functions = cluster_df["function"].value_counts()
        print(f"\n{label}")
        for func, count in functions.items():
            print(f"  {func}: {count}")

    # Visualize
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    html_path = create_visualization(df, OUTPUT_DIR)

    print("\n" + "=" * 60)
    print("Done! Open the HTML file in your browser:")
    print(f"  {html_path}")
    print("=" * 60)


if __name__ == "__main__":
    main()
