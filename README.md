# Azure AI Embeddings — Risk Assessment Clustering

This project uses Azure OpenAI embeddings to semantically analyze and cluster enterprise risk assessment descriptions. It takes a dataset of 50 risk records across functions like IT, Finance, HR, Legal & Compliance, Procurement, and Operations, generates vector embeddings for each risk description, then clusters and visualizes them to reveal natural groupings by semantic similarity.

## How It Works

The pipeline has three stages: infrastructure provisioning, embedding generation, and clustering/visualization.

### 1. Infrastructure (Terraform)

The `terraform/` directory provisions the Azure resources needed to run the embedding model. It creates a resource group, an Azure OpenAI Cognitive Services account, and deploys the `text-embedding-ada-002` model. After `terraform apply`, it writes a `.env` file to the project root containing the endpoint URL, API key, deployment name, and API version — everything the Python scripts need to authenticate.

Resources created:
- Resource Group: `rg-ai-embeddings-dev`
- Azure OpenAI Service: `cog-ai-embeddings-dev`
- Model Deployment: `text-embedding-ada-002`

### 2. Embedding Generation (`src/embed.py`)

Reads `data/risk_assessment_data.csv` (50 risk records with ID, function, owner, and description), loads credentials from `.env`, and calls the Azure OpenAI embeddings API in batches of 16. Each risk description is converted into a 1536-dimensional vector. The output — embeddings plus metadata — is saved to `output/embeddings.json`.

### 3. Clustering & Visualization (`src/cluster.py`)

Reads the embeddings from the previous step and performs three operations:

- **K-Means clustering** with automatic cluster count selection via silhouette score analysis (testing k=3 through k=9), or a manual override via `--clusters N`.
- **UMAP dimensionality reduction** from 1536D down to 2D for plotting, using cosine distance.
- **Interactive Plotly visualization** saved as `output/risk_clusters.html`, with hover details showing risk ID, function, owner, and description. Also saves a static PNG and a `cluster_summary.csv`.

Embeddings are L2-normalized before clustering so K-Means operates in cosine similarity space.

## Project Structure

```
├── data/
│   └── risk_assessment_data.csv    # 50 risk records across 6 functions
├── src/
│   ├── embed.py                    # Generate embeddings via Azure OpenAI
│   └── cluster.py                  # Cluster and visualize embeddings
├── terraform/
│   ├── main.tf                     # Azure resource definitions + .env generation
│   ├── variables.tf                # Configurable project name, region, model, capacity
│   └── outputs.tf                  # Resource group, endpoint, key, deployment name
├── output/                         # Generated at runtime (gitignored)
│   ├── embeddings.json
│   ├── risk_clusters.html
│   ├── risk_clusters.png
│   └── cluster_summary.csv
├── requirements.txt
└── .env                            # Generated by Terraform (gitignored)
```

## Prerequisites

- Azure CLI installed and authenticated (`az login`)
- Terraform >= 1.0
- Python 3.8+
- An Azure subscription with OpenAI access

## Usage

### Deploy Infrastructure

```bash
export ARM_SUBSCRIPTION_ID="your-subscription-id"
cd terraform
terraform init
terraform plan
terraform apply
```

### Generate Embeddings

```bash
pip install -r requirements.txt
python src/embed.py
```

### Cluster and Visualize

```bash
python src/cluster.py              # auto-detect cluster count
python src/cluster.py --clusters 6 # manual override
```

Open `output/risk_clusters.html` in a browser to explore the interactive scatter plot.

## Cleanup

```bash
cd terraform
terraform destroy
```

## Security

The `.env` file contains your Azure OpenAI API key and is gitignored. Never commit it to source control.